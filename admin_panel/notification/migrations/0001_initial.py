# Generated by Django 4.2.7 on 2023-11-17 10:44

import django.contrib.postgres.fields
from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Mail',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('context', models.TextField()),
                ('email', models.EmailField(max_length=254, verbose_name='Email')),
            ],
            options={
                'verbose_name': 'Mail',
                'verbose_name_plural': 'Mails',
                'db_table': 'notifications"."mail',
            },
        ),
        migrations.CreateModel(
            name='Notification',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255, unique=True, verbose_name='Name')),
                ('description', models.TextField(blank=True, verbose_name='Description')),
                ('destination', models.CharField(choices=[('Адрес электронной почты', 'Email'), ('PUSH', 'Push'), ('SMS', 'Sms')], max_length=64, verbose_name='Destination')),
            ],
            options={
                'verbose_name': 'Notification',
                'verbose_name_plural': 'Notifications',
                'db_table': 'notifications"."notification',
            },
        ),
        migrations.CreateModel(
            name='NotificationTemplate',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=255, verbose_name='Name')),
                ('subject', models.CharField(max_length=255, verbose_name='Subject')),
                ('template', models.TextField(default='', verbose_name='HTML code or Text')),
                ('notification', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='notification.notification')),
            ],
            options={
                'verbose_name': 'Template',
                'verbose_name_plural': 'Templates',
                'db_table': 'notifications"."template',
            },
        ),
        migrations.CreateModel(
            name='Subscribe',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('user_id', models.UUIDField(blank=True, null=True, verbose_name='User')),
                ('notification', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='notification.notification')),
            ],
            options={
                'verbose_name': 'Subscribe',
                'verbose_name_plural': 'Subscribes',
                'db_table': 'notifications"."subscribe',
            },
        ),
        migrations.CreateModel(
            name='Schedule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('freq', models.CharField(blank=True, choices=[('Yearly', 'Yearly'), ('Monthly', 'Monthly'), ('Weekly', 'Weekly'), ('Daily', 'Daily'), ('Hourly', 'Hourly'), ('Minutely', 'Minutely'), ('Secondly', 'Secondly')], max_length=16, null=True)),
                ('dtstart', models.DateTimeField(blank=True, help_text='The recurrence start. Besides being the base for the recurrence, missing parameters in the final recurrence instances will also be extracted from this date. If not given, datetime.now() will be used instead', null=True)),
                ('interval', models.PositiveSmallIntegerField(blank=True, help_text='The interval between each freq iteration. For example, when using YEARLY, an interval of 2 means once every two years, but with HOURLY, it means once every two hours. The default interval is 1', null=True)),
                ('wkst', models.CharField(blank=True, help_text='The week start day. Must be one of the MO, TU, WE constants, or an integer, specifying the first day of the week. This will affect recurrences based on weekly periods. The default week start is got from calendar.firstweekday(), and may be modified by calendar.setfirstweekday()', max_length=255)),
                ('count', models.PositiveSmallIntegerField(blank=True, help_text='If given, this determines how many occurrences will be generated', null=True)),
                ('until', models.DateTimeField(blank=True, help_text='If given, this must be a datetime instance specifying the upper-bound limit of the recurrence. The last recurrence in the rule is the greatest datetime that is less than or equal to the value specified in the until parameter', null=True)),
                ('bysetpos', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, positive or negative. Each given integer will specify an occurrence number, corresponding to the nth occurrence of the rule inside the frequency period. For example, a bysetpos of -1 if combined with a MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will result in the last work day of every month.', null=True, size=None)),
                ('bymonth', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the months to apply the recurrence to', null=True, size=None)),
                ('bymonthday', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the month days to apply the recurrence to', null=True, size=None)),
                ('byyearday', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the year days to apply the recurrence to', null=True, size=None)),
                ('byeaster', django.contrib.postgres.fields.ArrayField(base_field=models.SmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, positive or negative. Each integer will define an offset from the Easter Sunday. Passing the offset 0 to byeaster will yield the Easter Sunday itself. This is an extension to the RFC specification', null=True, size=None)),
                ('byweekno', django.contrib.postgres.fields.ArrayField(base_field=models.SmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the week numbers to apply the recurrence to. Week numbers have the meaning described in ISO8601, that is, the first week of the year is that containing at least four days of the new year', null=True, size=None)),
                ('byhour', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the hours to apply the recurrence to.', null=True, size=None)),
                ('byminute', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the minutes to apply the recurrence to.', null=True, size=None)),
                ('bysecond', django.contrib.postgres.fields.ArrayField(base_field=models.PositiveSmallIntegerField(blank=True, null=True), blank=True, help_text='If given, it must be either an integer, or a sequence of integers, meaning the seconds to apply the recurrence to.', null=True, size=None)),
                ('notification', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='notification.notification')),
            ],
            options={
                'verbose_name': 'Schedule',
                'verbose_name_plural': 'Schedule',
                'db_table': 'notifications"."schedule',
            },
        ),
        migrations.CreateModel(
            name='NewFilm',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created', models.DateTimeField(auto_now_add=True)),
                ('film', models.UUIDField(verbose_name='Film')),
                ('genre', models.UUIDField(verbose_name='Genre')),
                ('date', models.DateTimeField(verbose_name='Date')),
            ],
            options={
                'verbose_name': 'New film',
                'verbose_name_plural': 'New films',
                'db_table': 'notifications"."new_film',
                'indexes': [models.Index(fields=['date'], name='new_film_date')],
            },
        ),
        migrations.CreateModel(
            name='EventNotification',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('event', models.CharField(max_length=255, verbose_name='Event')),
                ('notification', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='notification.notification')),
            ],
            options={
                'verbose_name': 'Event Notification',
                'verbose_name_plural': 'Events Notifications',
                'db_table': 'notifications"."event_notification',
            },
        ),
    ]
